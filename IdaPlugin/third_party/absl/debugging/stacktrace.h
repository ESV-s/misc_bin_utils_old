// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: stacktrace.h
// -----------------------------------------------------------------------------
//
// Этот файл содержит процедуры извлечения текущей трассировки стека и связанных с ней стековых кадров.
// Эти функции являются потокобезопасными и асинхронно-сигналобезопасными.
//
// Обратите внимание, что функциональность трассировки стека зависит от платформы
// и в большинстве случаев требует дополнительной поддержки со стороны компилятора/системы сборки.
// (То есть эта функциональность обычно работает только на тех платформах/сборках,
// которые специально настроены на ее поддержку).
//
// Примечание: трассировка стека в Abseil, не использующая символизатор,
// приводит к появлению кадров, состоящих из адресов функций, а не из удобочитаемых имен функций.
// (Информацию о символизации этих значений см. в файле symbolize.h).

#ifndef ABSL_DEBUGGING_STACKTRACE_H_
#define ABSL_DEBUGGING_STACKTRACE_H_

#include "third_party/absl/base/config.h"

namespace absl {
	ABSL_NAMESPACE_BEGIN

		///\n GetStackFrames()
		///\n
		///\n Записывает значения программного счетчика для кадров глубиной до `max_depth`,
		///\n пропуская последние кадры стека `skip_count`,
		///\n сохраняет соответствующие значения и размеры в буферах `results` и `sizes`,
		///\n и возвращает количество сохраненных кадров.
		///\n (Обратите внимание, что кадр, сгенерированный для самой процедуры `absl::GetStackFrames()`, также пропускается).
		///\n
		///\n Example:
		///\n
		///\n      main() { foo(); }
		///\n      foo() { bar(); }
		///\n      bar() {
		///\n        void* result[10];
		///\n        int sizes[10];
		///\n        int depth = absl::GetStackFrames(result, sizes, 10, 1);
		///\n      }
		///\n
		///\n Текущий кадр стека будет состоять из трех вызовов функций: `bar()`,
		///\n `foo()`, а затем `main()`; однако, поскольку вызов `GetStackFrames()` устанавливает `skip_count` в `1`,
		///\n он пропустит кадр для `bar()`, самого последнего вызова функции.
		///\n Поэтому он вернет 2 и заполнит `result` программными счетчиками в следующих функциях:
		///\n
		///\n      result[0]       foo()
		///\n      result[1]       main()
		///\n
		///\n (Примечание: на практике после `main()` может быть добавлено еще несколько записей для учета процессов запуска).
		///\n Соответствующие размеры стековых кадров также будут записаны:
		///\n
		///\n    sizes[0]       16
		///\n    sizes[1]       16
		///\n
		///\n (Размеры стековых кадров `16` выше приведены лишь для наглядности).
		///\n Размеры кадров стека, равные 0 или меньше, указывают на то, что эти размеры кадров не удалось идентифицировать.
		///\n
		///\n Эта процедура может вернуть меньше записей кадра стека, чем доступно.
		///\n Также обратите внимание, что `result` и `sizes` должны быть не нулевыми.
		extern int GetStackFrames(
			void** result,
			int* sizes,
			int max_depth,
			int skip_count);

	///\n GetStackFramesWithContext()\n
	///\n
	/// Записывает значения программного счетчика, полученные от обработчика сигнала.\n
	/// Записывает значения программных счетчиков для кадров глубиной до `max_depth`,\n
	/// пропуская последние кадры стека `skip_count`,\n
	/// сохраняет соответствующие значения и размеры в буферах `results` и `sizes`\n
	/// и возвращает количество сохраненных кадров.\n
	/// (Заметим, что кадр, сгенерированный для самой процедуры\n
	/// `absl::GetStackFramesWithContext()`, также пропускается).\n
	///\n
	/// Параметр `uc`, если он не является нулевым, должен представлять собой указатель на значение `ucontext_t`,\n
	/// передаваемое обработчику сигналов, зарегистрированному через поле `sa_sigaction` структуры `sigaction`.\n
	/// (См. http:///man7.org/linux/man-pages/man2/sigaction.2.html.)\n
	/// Значение `uc` при определенных условиях может помочь распаковщику стека получить более точную трассировку стека.\n
	/// `uc` может быть безопасно равно null.\n
	///\n
	/// Выходной параметр `min_dropped_frames`, если он не равен null, указывает на место,\n
	/// где следует отмечать все выпавшие кадры стека,\n
	/// если таковые имеются из-за ограничений буфера или по другим причинам.\n
	/// (Это значение будет установлено в `0`, если ни один кадр не был сброшен).\n
	/// Гарантируется,\n
	/// что количество всех кадров стека будет >= skip_count + max_depth + *min_dropped_frames.\n
	extern int GetStackFramesWithContext(
		void** result,
		int* sizes,
		int max_depth,
		int skip_count,
		const void* uc,
		int* min_dropped_frames);

	///\n GetStackTrace()\n
	/// последние `skip_count` кадров стека,\n
	/// Записывает значения счетчиков программы для фреймов глубиной до `max_depth`,\n
	/// пропуская их, сохраняет соответствующие значения в `results`,\n
	/// и возвращает количество сохраненных фреймов. Отметим, что эта функция\n
	/// аналогична функции `absl::GetStackFrames()`, за исключением того,\n
	/// что она возвращает только трассировку стека, а не размеры стековых кадров.\n
	///\n
	/// Example:\n
	///\n
	///      main() { foo(); }\n
	///      foo() { bar(); }\n
	///      bar() {\n
	///        void* result[10];\n
	///        int depth = absl::GetStackTrace(result, 10, 1);\n
	///      }\n
	///\n
	/// This produces:\n
	///\n
	///      result[0]       foo\n
	///      result[1]       main\n
	///           ....       ...\n
	///\n
	/// `result` must not be null.\n
	extern int GetStackTrace(
		void** result,
		int max_depth,
		int skip_count);

	///\n GetStackTraceWithContext()\n
	///\n
	/// Запись значений программного счетчика, полученных от обработчика сигнала.\n
	/// Записывает значения программных счетчиков до `max_depth` кадров,\n
	/// пропуская последние `skip_count` кадров стека,\n
	/// сохраняет соответствующие значения в `results`\n
	/// и возвращает количество сохраненных кадров.\n
	/// (Обратите внимание, что кадр, сгенерированный для самой процедуры\n
	/// `absl::GetStackFramesWithContext()`, также пропускается).\n
	///\n
	/// Параметр `uc`, если он не является нулевым, должен быть указателем на значение `ucontext_t`,\n
	/// передаваемое обработчику сигналов, зарегистрированному через поле `sa_sigaction` структуры `sigaction`.\n
	/// (См. http:///man7.org/linux/man-pages/man2/sigaction.2.html.)\n
	/// Значение `uc` может помочь распаковщику стека предоставить более\n
	/// качественную трассировку стека при определенных условиях.\n
	/// `uc` может быть безопасно равно null.\n
	///\n
	/// Выходной параметр `min_dropped_frames`, если он не равен null,\n
	/// указывает на место, где следует отмечать все выпавшие кадры стека,\n
	/// если таковые имеются из-за ограничений буфера или по другим причинам.\n
	/// (Это значение будет установлено в `0`, если ни один кадр не был сброшен).\n
	/// Гарантируется, что количество всех кадров стека\n
	/// будет >= skip_count + max_depth + *min_dropped_frames.\n
	extern int GetStackTraceWithContext(
		void** result,
		int max_depth,
		int skip_count,
		const void* uc,
		int* min_dropped_frames);

	///\n SetStackUnwinder()
	///\n
	/// Предоставляет пользовательскую функцию для раскрутки кадров стека,\n
	/// которая будет использоваться вместо стандартного раскрутчика стека\n
	/// при вызове статических функций GetStack{Frames,Trace}{,WithContext}(), описанных выше.\n
	///\n
	/// Аргументы, передаваемые функции раскрутчика,\n
	/// будут соответствовать аргументам, передаваемым функции\n
	/// `absl::GetStackFramesWithContext()`, за исключением того,\n
	/// что sizes будет ненулевым, если вызывающая сторона интересуется размерами фреймов.\n
	///\n
	/// Если значение unwinder равно null,\n
	/// то мы возвращаемся к стандартному поведению трассировки стека.\n
	///\n
	/// *****************************************************************************\n
	/// WARNING\n
	/// *****************************************************************************\n
	///\n
	/// absl::SetStackUnwinder не подходит для общего использования.\n
	/// Она предназначена для пользовательских режимов работы.\n
	/// Некоторые моменты, на которые следует обратить внимание при вызове `absl::SetStackUnwinder()`:\n
	///\n
	/// (a) Размотчик может вызываться из обработчиков сигналов и поэтому должен быть async-signal-safe.\n
	///\n
	/// (b) Даже после того, как пользовательский разматыватель стека был снят с регистрации,\n
	/// другие потоки могут продолжать использовать этот размотчик.\n
	/// Поэтому не следует очищать состояние, которое может понадобиться старому разматывателю.\n
	/// *****************************************************************************\n
	extern void SetStackUnwinder(int(*unwinder)(
		void** pcs,
		int* sizes,
		int max_depth,
		int skip_count,
		const void* uc,
		int* min_dropped_frames));

	///\n DefaultStackUnwinder()
	///\n
	/// Записывает значения программных счетчиков до `max_depth` кадров,\n
	/// пропуская последние `skip_count` кадры стека,\n
	/// и сохраняет соответствующие значения в `pcs`.\n
	/// (Заметим, что кадр, сгенерированный для этого вызова, также пропускается).\n
	/// Эта функция работает как универсальная утилита для распутывания стека;\n
	/// лучше использовать более специфические функции\n
	/// `GetStack{Trace,Frames}{,WithContext}()`, приведенные выше.\n
	///\n
	/// Если вы установили свой собственный размотчик стека\n
	/// (с помощью функции `SetStackUnwinder()`, описанной выше\n
	/// вы все равно можете получить размотчик стека по умолчанию\n
	/// вызвав функцию `DefaultStackUnwinder()`\n
	/// который проигнорирует любой ранее установленный размотчик стеков\n
	/// и использует вместо него размотчик по умолчанию.\n
	///
	/// Поскольку эта функция является общей, только `pcs` гарантированно\n
	/// будет не нулевым при возврате.\n
	/// Допустимо, чтобы при вызове функции `sizes`, `uc`\n
	/// и `min_dropped_frames` были равны null.\n
	///
	/// Семантика такая же, как у соответствующей функции `GetStack*()` в случае,\n
	/// когда `absl::SetStackUnwinder()` никогда не вызывалась.\n
	/// Эквивалентами являются:\n
	///\n
	///                       null sizes         |        non-nullptr sizes\n
	///             |==========================================================|\n
	///     null uc | GetStackTrace()            | GetStackFrames()            |\n
	/// non-null uc | GetStackTraceWithContext() | GetStackFramesWithContext() |\n
	///             |==========================================================|\n
	extern int DefaultStackUnwinder(
		void** pcs,
		int* sizes,
		int max_depth,
		int skip_count,
		const void* uc,
		int* min_dropped_frames);

	namespace debugging_internal {

		///\n
/// Возвращает true для платформ, на которых ожидается наличие\n
/// работоспособных реализаций трассировки стека.\n
/// Предназначен для использования в тестах, которые хотят исключить проверку логики,\n
/// заведомо неработоспособной из-за неработающих трассировок стека.
		extern bool StackTraceWorksForTest();
	}  // namespace debugging_internal
	ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_STACKTRACE_H_
